<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
    <head>
        <title>
            Practical: An MP3 Database
        </title>
        <link rel="stylesheet" type="text/css" href="style.css">
    </head>
    <body>
        <h1>
            27. Practical: An MP3 Database
        </h1>
        <p>
            In this chapter you'll revisit the idea first explored in Chapter 3 of building an in-memory database out of basic Lisp data structures. This time your goal is to hold information that you'll extract from a collection of MP3 files using the ID3v2 library from Chapter 25. You'll then use this database in Chapters 28 and 29 as part of a Web-based streaming MP3 server. Of course, this time around you can use some of the language features you've learned since Chapter 3 to build a more sophisticated version.
        </p>
        <h2>
            <a name="the-database" id="the-database">The Database</a>
        </h2>
        <p>
            The main problem with the database in Chapter 3 is that there's only one table, the list stored in the variable <code>*db*</code>. Another is that the code doesn't know anything about what type of values are stored in different columns. In Chapter 3 you got away with that by using the fairly general-purpose <code><b>EQUAL</b></code> method to compare column values when selecting rows from the database, but you would've been in trouble if you had wanted to store values that couldn't be compared with <code><b>EQUAL</b></code> or if you had wanted to sort the rows in the database since there's no ordering function that's as general as <code><b>EQUAL</b></code>.
        </p>
        <p>
            This time you'll solve both problems by defining a class, <code>table</code>, to represent individual database tables. Each <code>table</code> instance will consist of two slots--one to hold the table's data and another to hold information about the columns in the table that database operations will be able to use. The class looks like this:
        </p>
        <pre>
(defclass table ()
  ((rows   :accessor rows   :initarg :rows :initform (make-rows))
   (schema :accessor schema :initarg :schema)))
</pre>
        <p>
            As in Chapter 3, you can represent the individual rows with plists, but this time around you'll create an abstraction that will make that an implementation detail you can change later without too much trouble. And this time you'll store the rows in a vector rather than a list since certain operations that you'll want to support, such as random access to rows by a numeric index and the ability to sort a table, can be more efficiently implemented with vectors.
        </p>
        <p>
            The function <code>make-rows</code> used to initialize the <code>rows</code> slot can be a simple wrapper around <code><b>MAKE-ARRAY</b></code> that builds an empty, adjustable,vector with a fill pointer.
        </p>
        <div class="sidebarhead">
            The Package
        </div>
        <div class="sidebar">
            <p>
                The package for the code you'll develop in this chapter looks like this:
            </p>
            <pre>
(defpackage :com.gigamonkeys.mp3-database
  (:use :common-lisp 
        :com.gigamonkeys.pathnames
        :com.gigamonkeys.macro-utilities
        :com.gigamonkeys.id3v2)
  (:export  :*default-table-size*
            :*mp3-schema*
            :*mp3s*
            :column
            :column-value
            :delete-all-rows
            :delete-rows
            :do-rows
            :extract-schema
            :in
            :insert-row
            :load-database
            :make-column
            :make-schema
            :map-rows
            :matching
            :not-nullable
            :nth-row
            :random-selection
            :schema
            :select
            :shuffle-table
            :sort-rows
            :table
            :table-size
            :with-column-values))
</pre>
            <p>
                The <code>:use</code> section gives you access to the functions and macros whose names are exported from the packages defined in Chapter 15, 8, and 25 and the <code>:export</code> section exports the API this library will provide, which you'll use in Chapter 29.
            </p>
        </div>
        <pre>
(defparameter *default-table-size* 100)

(defun make-rows (&amp;optional (size *default-table-size*))
  (make-array size :adjustable t :fill-pointer 0))
</pre>
        <p>
            To represent a table's schema, you need to define another class, <code>column</code>, each instance of which will contain information about one column in the table: its name, how to compare values in the column for equality and ordering, a default value, and a function that will be used to normalize the column's values when inserting data into the table and when querying the table. The <code>schema</code> slot will hold a list of <code>column</code> objects. The class definition looks like this:
        </p>
        <pre>
(defclass column ()
  ((name               
    :reader name
    :initarg :name)

   (equality-predicate
    :reader equality-predicate
    :initarg :equality-predicate)

   (comparator
    :reader comparator
    :initarg :comparator)

   (default-value
    :reader default-value
    :initarg :default-value
    :initform nil)

   (value-normalizer
    :reader value-normalizer
    :initarg :value-normalizer
    :initform #'(lambda (v column) (declare (ignore column)) v))))
</pre>
        <p>
            The <code>equality-predicate</code> and <code>comparator</code> slots of a <code>column</code> object hold functions used to compare values from the given column for equivalence and ordering. Thus, a column containing string values might have <code><b>STRING=</b></code> as its <code>equality-predicate</code> and <code><b>STRING&lt;</b></code> as its <code>comparator</code>, while a column containing numbers might have <code><b>=</b></code> and <code><b>&lt;</b></code>.
        </p>
        <p>
            The <code>default-value</code> and <code>value-normalizer</code> slots are used when inserting rows into the database and, in the case of <code>value-normalizer</code>, when querying the database. When you insert a row into the database, if no value is provided for a particular column, you can use the value stored in the <code>column</code>'s <code>default-value</code> slot. Then the value--defaulted or otherwise--is normalized by passing it and the column object to the function stored in the <code>value-normalizer</code> slot. You pass the column in case the <code>value-normalizer</code> function needs to use some data associated with the column object. (You'll see an example of this in the next section.) You should also normalize values passed in queries before comparing them with values in the database.
        </p>
        <p>
            Thus, the <code>value-normalizer</code>'s responsibility is primarily to return a value that can be safely and correctly passed to the <code>equality-predicate</code> and <code>comparator</code> functions. If the <code>value-normalizer</code> can't figure out an appropriate value to return, it can signal an error.
        </p>
        <p>
            The other reason to normalize values before you store them in the database is to save both memory and CPU cycles. For instance, if you have a column that's going to contain string values but the number of distinct strings that will be stored in the column is small--for instance, the genre column in the MP3 database--you can save space and speed by using the <code>value-normalizer</code> to <i>intern</i> the strings (translate all <code><b>STRING=</b></code> values to a single string object). Thus, you'll need only as many strings as there are distinct values, regardless of how many rows are in the table, and you can use <code><b>EQL</b></code> to compare column values rather than the slower <code><b>STRING=</b></code>.<sup>1</sup>
        </p>
        <h2>
            <a name="defining-a-schema" id="defining-a-schema">Defining a Schema</a>
        </h2>
        <p>
            Thus, to make an instance of <code>table</code>, you need to build a list of <code>column</code> objects. You could build the list by hand, using <code><b>LIST</b></code> and <code><b>MAKE-INSTANCE</b></code>. But you'll soon notice that you're frequently making a lot column objects with the same comparator and equality-predicate combinations. This is because the combination of a comparator and equality predicate essentially defines a column type. It'd be nice if there was a way to give those types names that would allow you to say simply that a given column is a string column, rather than having to specify <code><b>STRING&lt;</b></code> as its comparator and <code><b>STRING=</b></code> as its equality predicate. One way is to define a generic function, <code>make-column</code>, like this:
        </p>
        <pre>
(defgeneric make-column (name type &amp;optional default-value))
</pre>
        <p>
            Now you can implement methods on this generic function that specialize on <code>type</code> with <code><b>EQL</b></code> specializers and return <code>column</code> objects with the slots filled in with appropriate values. Here's the generic function and methods that define column types for the type names <code>string</code> and <code>number</code>:
        </p>
        <pre>
(defmethod make-column (name (type (eql 'string)) &amp;optional default-value)
  (make-instance
   'column 
   :name name
   :comparator #'string&lt; 
   :equality-predicate #'string=
   :default-value default-value
   :value-normalizer #'not-nullable))

(defmethod make-column (name (type (eql 'number)) &amp;optional default-value)
  (make-instance 
   'column
   :name name
   :comparator #'&lt; 
   :equality-predicate #'=
   :default-value default-value))
</pre>
        <p>
            The following function, <code>not-nullable</code>, used as the <code>value-normalizer</code> for <code>string</code> columns, simply returns the value it's given unless the value is <code><b>NIL</b></code>, in which case it signals an error:
        </p>
        <pre>
(defun not-nullable (value column)
  (or value (error "Column ~a can't be null" (name column))))
</pre>
        <p>
            This is important because <code><b>STRING&lt;</b></code> and <code><b>STRING=</b></code> will signal an error if called on <code><b>NIL</b></code>; it's better to catch bad values before they go into the table rather than when you try to use them.<sup>2</sup>
        </p>
        <p>
            Another column type you'll need for the MP3 database is an <code>interned-string</code> whose values are interned as discussed previously. Since you need a hash table in which to intern values, you should define a subclass of <code>column</code>, <code>interned-values-column</code>, that adds a slot whose value is the hash table you use to intern.
        </p>
        <p>
            To implement the actual interning, you'll also need to provide an <code>:initform</code> for <code>value-normalizer</code> of a function that interns the value in the column's <code>interned-values</code> hash table. And because one of the main reasons to intern values is to allow you to use <code><b>EQL</b></code> as the equality predicate, you should also add an <code>:initform</code> for the <code>equality-predicate</code> of <code>#'eql</code>.
        </p>
        <pre>
(defclass interned-values-column (column)
  ((interned-values
    :reader interned-values
    :initform (make-hash-table :test #'equal))
   (equality-predicate :initform #'eql)
   (value-normalizer   :initform #'intern-for-column)))

(defun intern-for-column (value column)
  (let ((hash (interned-values column)))
    (or (gethash (not-nullable value column) hash)
        (setf (gethash value hash) value))))
</pre>
        <p>
            You can then define a <code>make-column</code> method specialized on the name <code>interned-string</code> that returns an instance of <code>interned-values-column</code>.
        </p>
        <pre>
(defmethod make-column (name (type (eql 'interned-string)) &amp;optional default-value)
  (make-instance 
   'interned-values-column
   :name name
   :comparator #'string&lt; 
   :default-value default-value))
</pre>
        <p>
            With these methods defined on <code>make-column</code>, you can now define a function, <code>make-schema</code>, that builds a list of <code>column</code> objects from a list of column specifications consisting of a column name, a column type name, and, optionally, a default value.
        </p>
        <pre>
(defun make-schema (spec)
  (mapcar #'(lambda (column-spec) (apply #'make-column column-spec)) spec))
</pre>
        <p>
            For instance, you can define the schema for the table you'll use to store data extracted from MP3s like this:
        </p>
        <pre>
(defparameter *mp3-schema* 
  (make-schema 
   '((:file     string)
     (:genre    interned-string "Unknown")
     (:artist   interned-string "Unknown")
     (:album    interned-string "Unknown")
     (:song     string)
     (:track    number 0)
     (:year     number 0)
     (:id3-size number))))
</pre>
        <p>
            To make an actual table for holding information about MP3s, you pass <code>*mp3-schema*</code> as the <code>:schema</code> initarg to <code><b>MAKE-INSTANCE</b></code>.
        </p>
        <pre>
(defparameter *mp3s* (make-instance 'table :schema *mp3-schema*))
</pre>
        <h2>
            <a name="inserting-values" id="inserting-values">Inserting Values</a>
        </h2>
        <p>
            Now you're ready to define your first table operation, <code>insert-row</code>, which takes a plist of names and values and a table and adds a row to the table containing the given values. The bulk of the work is done in a helper function, <code>normalize-row</code>, that builds a plist with a defaulted, normalized value for each column, using the values from <code>names-and-values</code> if available and the <code>default-value</code> for the column if not.
        </p>
        <pre>
(defun insert-row (names-and-values table)
  (vector-push-extend (normalize-row names-and-values (schema table)) (rows table)))

(defun normalize-row (names-and-values schema)
  (loop
     for column in schema
     for name  = (name column)
     for value = (or (getf names-and-values name) (default-value column))
     collect name
     collect (normalize-for-column value column)))
</pre>
        <p>
            It's worth defining a separate helper function, <code>normalize-for-column</code>, that takes a value and a <code>column</code> object and returns the normalized value because you'll need to perform the same normalization on query arguments.
        </p>
        <pre>
(defun normalize-for-column (value column)
  (funcall (value-normalizer column) value column))
</pre>
        <p>
            Now you're ready to combine this database code with code from previous chapters to build a database of data extracted from MP3 files. You can define a function, <code>file-&gt;row</code>, that uses <code>read-id3</code> from the ID3v2 library to extract an ID3 tag from a file and turns it into a plist that you can pass to <code>insert-row</code>.
        </p>
        <pre>
(defun file-&gt;row (file)
  (let ((id3 (read-id3 file)))
    (list
     :file   (namestring (truename file))
     :genre  (translated-genre id3)
     :artist (artist id3)
     :album  (album id3)
     :song   (song id3)
     :track  (parse-track (track id3))
     :year   (parse-year (year id3))
     :id3-size (size id3))))
</pre>
        <p>
            You don't have to worry about normalizing the values since <code>insert-row</code> takes care of that for you. You do, however, have to convert the string values returned by the <code>track</code> and <code>year</code> into numbers. The track number in an ID3 tag is sometimes stored as the ASCII representation of the track number and sometimes as a number followed by a slash followed by the total number of tracks on the album. Since you care only about the actual track number, you should use the <code>:end</code> argument to <code><b>PARSE-INTEGER</b></code> to specify that it should parse only up to the slash, if any.<sup>3</sup>
        </p>
        <pre>
(defun parse-track (track)
  (when track (parse-integer track :end (position #\/ track))))

(defun parse-year (year)
  (when year (parse-integer year)))
</pre>
        <p>
            Finally, you can put all these functions together, along with <code>walk-directory</code> from the portable pathnames library and <code>mp3-p</code> from the ID3v2 library, to define a function that loads an MP3 database with data extracted from all the MP3 files it can find under a given directory.
        </p>
        <pre>
(defun load-database (dir db)
  (let ((count 0))
    (walk-directory 
     dir 
     #'(lambda (file)
         (princ #\.)
         (incf count)
         (insert-row (file-&gt;row file) db))
     :test #'mp3-p)
    (format t "~&amp;Loaded ~d files into database." count)))
</pre>
        <h2>
            <a name="querying-the-database" id="querying-the-database">Querying the Database</a>
        </h2>
        <p>
            Once you've loaded your database with data, you'll need a way to query it. For the MP3 application you'll need a slightly more sophisticated query function than you wrote in Chapter 3. This time around you want not only to be able to select rows matching particular criteria but also to limit the results to particular columns, to limit the results to unique rows, and perhaps to sort the rows by particular columns. In keeping with the spirit of relational database theory, the result of a query will be a new <code>table</code> object containing the desired rows and columns.
        </p>
        <p>
            The query function you'll write, <code>select</code>, is loosely modeled on the <code>SELECT</code> statement from Structured Query Language (SQL). It'll take five keyword parameters: <code>:from</code>, <code>:columns</code>, <code>:where</code>, <code>:distinct</code>, and <code>:order-by</code>. The <code>:from</code> argument is the <code>table</code> object you want to query. The <code>:columns</code> argument specifies which columns should be included in the result. The value should be a list of column names, a single column name, or a <code><b>T</b></code>, the default, meaning return all columns. The <code>:where</code> argument, if provided, should be a function that accepts a row and returns true if it should be included in the results. In a moment, you'll write two functions, <code>matching</code> and <code>in</code>, that return functions appropriate for use as <code>:where</code> arguments. The <code>:order-by</code> argument, if supplied, should be a list of column names; the results will be sorted by the named columns. As with the <code>:columns</code> argument, you can specify a single column using just the name, which is equivalent to a one-item list containing the same name. Finally, the <code>:distinct</code> argument is a boolean that says whether to eliminate duplicate rows from the results. The default value for <code>:distinct</code> is <code><b>NIL</b></code>.
        </p>
        <p>
            Here are some examples of using <code>select</code>:
        </p>
        <pre>
;; Select all rows where the :artist column is "Green Day"
(select :from *mp3s* :where (matching *mp3s* :artist "Green Day"))

;; Select a sorted list of artists with songs in the genre "Rock"
(select
  :columns :artist
  :from *mp3s*
  :where (matching *mp3s* :genre "Rock")
  :distinct t
  :order-by :artist)
</pre>
        <p>
            The implementation of <code>select</code> with its immediate helper functions looks like this:
        </p>
        <pre>
(defun select (&amp;key (columns t) from where distinct order-by)
  (let ((rows (rows from))
        (schema (schema from)))

    (when where
      (setf rows (restrict-rows rows where)))

    (unless (eql columns 't)
      (setf schema (extract-schema (mklist columns) schema))
      (setf rows (project-columns rows schema)))

    (when distinct
      (setf rows (distinct-rows rows schema)))

    (when order-by
      (setf rows (sorted-rows rows schema (mklist order-by))))

    (make-instance 'table :rows rows :schema schema)))

(defun mklist (thing)
  (if (listp thing) thing (list thing)))

(defun extract-schema (column-names schema)
  (loop for c in column-names collect (find-column c schema)))

(defun find-column (column-name schema)
  (or (find column-name schema :key #'name)
      (error "No column: ~a in schema: ~a" column-name schema)))

(defun restrict-rows (rows where)
  (remove-if-not where rows))

(defun project-columns (rows schema)
  (map 'vector (extractor schema) rows))

(defun distinct-rows (rows schema)
  (remove-duplicates rows :test (row-equality-tester schema)))

(defun sorted-rows (rows schema order-by)
  (sort (copy-seq rows) (row-comparator order-by schema)))
</pre>
        <p>
            Of course, the really interesting part of <code>select</code> is how you implement the functions <code>extractor</code>, <code>row-equality-tester</code>, and <code>row-comparator</code>.
        </p>
        <p>
            As you can tell by how they're used, each of these functions must return a function. For instance, <code>project-columns</code> uses the value returned by <code>extractor</code> as the function argument to <code><b>MAP</b></code>. Since the purpose of <code>project-columns</code> is to return a set of rows with only certain column values, you can infer that <code>extractor</code> returns a function that takes a row as an argument and returns a new row containing only the columns specified in the schema it's passed. Here's how you can implement it:
        </p>
        <pre>
(defun extractor (schema)
  (let ((names (mapcar #'name schema)))
    #'(lambda (row)
        (loop for c in names collect c collect (getf row c)))))
</pre>
        <p>
            Note how you can do the work of extracting the names from the schema outside the body of the closure: since the closure will be called many times, you want it to do as little work as possible each time it's called.
        </p>
        <p>
            The functions <code>row-equality-tester</code> and <code>row-comparator</code> are implemented in a similar way. To decide whether two rows are equivalent, you need to apply the appropriate equality predicate for each column to the appropriate column values. Recall from Chapter 22 that the <code><b>LOOP</b></code> clause <code>always</code> will return <code><b>NIL</b></code> as soon as a pair of values fails their test or will cause the <code><b>LOOP</b></code> to return <code><b>T</b></code>.
        </p>
        <pre>
(defun row-equality-tester (schema)
  (let ((names (mapcar #'name schema))
        (tests (mapcar #'equality-predicate schema)))
    #'(lambda (a b)
        (loop for name in names and test in tests
           always (funcall test (getf a name) (getf b name))))))
</pre>
        <p>
            Ordering two rows is a bit more complex. In Lisp, comparator functions return true if their first argument should be sorted ahead of the second and <code><b>NIL</b></code> otherwise. Thus, a <code><b>NIL</b></code> can mean that the second argument should be sorted ahead of the first <i>or</i> that they're equivalent. You want your row comparators to behave the same way: return <code><b>T</b></code> if the first row should be sorted ahead of the second and <code><b>NIL</b></code> otherwise.
        </p>
        <p>
            Thus, to compare two rows, you should compare the values from the columns you're sorting by, in order, using the appropriate comparator for each column. First call the comparator with the value from the first row as the first argument. If the comparator returns true, that means the first row should definitely be sorted ahead of the second row, so you can immediately return <code><b>T</b></code>.
        </p>
        <p>
            But if the column comparator returns <code><b>NIL</b></code>, then you need to determine whether that's because the second value should sort ahead of the first value or because they're equivalent. So you should call the comparator again with the arguments reversed. If the comparator returns true this time, it means the second column value sorts ahead of the first and thus the second row ahead of the first row, so you can return <code><b>NIL</b></code> immediately. Otherwise, the column values are equivalent, and you need to move onto the next column. If you get through all the columns without one row's value ever winning the comparison, then the rows are equivalent, and you return <code><b>NIL</b></code>. A function that implements this algorithm looks like this:
        </p>
        <pre>
(defun row-comparator (column-names schema)
  (let ((comparators (mapcar #'comparator (extract-schema column-names schema))))
    #'(lambda (a b)
        (loop
           for name in column-names
           for comparator in comparators
           for a-value = (getf a name)
           for b-value = (getf b name)
           when (funcall comparator a-value b-value) return t
           when (funcall comparator b-value a-value) return nil
           finally (return nil)))))
</pre>
        <h2>
            <a name="matching-functions" id="matching-functions">Matching Functions</a>
        </h2>
        <p>
            The <code>:where</code> argument to <code>select</code> can be any function that takes a row object and returns true if it should be included in the results. In practice, however, you'll rarely need the full power of arbitrary code to express query criteria. So you should provide two functions, <code>matching</code> and <code>in</code>, that will build query functions that allow you to express the common kinds of queries and that take care of using the proper equality predicates and value normalizers for each column.
        </p>
        <p>
            The workhouse query-function constructor will be <code>matching</code>, which returns a function that will match rows with specific column values. You saw how it was used in the earlier examples of <code>select</code>. For instance, this call to <code>matching</code>:
        </p>
        <pre>
(matching *mp3s* :artist "Green Day")
</pre>
        <p>
            returns a function that matches rows whose <code>:artist</code> value is "Green Day". You can also pass multiple names and values; the returned function matches when all the columns match. For example, the following returns a closure that matches rows where the artist is "Green Day" and the album is "American Idiot":
        </p>
        <pre>
(matching *mp3s* :artist "Green Day" :album "American Idiot")
</pre>
        <p>
            You have to pass <code>matching</code> the table object because it needs access to the table's schema in order to get at the equality predicates and value normalizer functions for the columns it matches against.
        </p>
        <p>
            You build up the function returned by <code>matching</code> out of smaller functions, each responsible for matching one column's value. To build these functions, you should define a function, <code>column-matcher</code>, that takes a <code>column</code> object and an unnormalized value you want to match and returns a function that accepts a single row and returns true when the value of the given column in the row matches the normalized version of the given value.
        </p>
        <pre>
(defun column-matcher (column value)
  (let ((name (name column))
        (predicate (equality-predicate column))
        (normalized (normalize-for-column value column)))
    #'(lambda (row) (funcall predicate (getf row name) normalized))))
</pre>
        <p>
            You then build a list of column-matching functions for the names and values you care about with the following function, <code>column-matchers</code>:
        </p>
        <pre>
(defun column-matchers (schema names-and-values)
  (loop for (name value) on names-and-values by #'cddr
     when value collect
       (column-matcher (find-column name schema) value)))
</pre>
        <p>
            Now you can implement <code>matching</code>. Again, note that you do as much work as possible outside the closure in order to do it only once rather than once per row in the table.
        </p>
        <pre>
(defun matching (table &amp;rest names-and-values)
  "Build a where function that matches rows with the given column values."
  (let ((matchers (column-matchers (schema table) names-and-values)))
    #'(lambda (row)
        (every #'(lambda (matcher) (funcall matcher row)) matchers))))
</pre>
        <p>
            This function is a bit of a twisty maze of closures, but it's worth contemplating for a moment to get a flavor of the possibilities of programming with functions as first-class objects.
        </p>
        <p>
            The job of <code>matching</code> is to return a function that will be invoked on each row in a table to determine whether it should be included in the new table. So, <code>matching</code> returns a closure with one parameter, <code>row</code>.
        </p>
        <p>
            Now recall that the function <code><b>EVERY</b></code> takes a predicate function as its first argument and returns true if, and only if, that function returns true each time it's applied to an element of the list passed as <code><b>EVERY</b></code>'s second argument. However, in this case, the list you pass to <code><b>EVERY</b></code> is itself a list of functions, the column matchers. What you want to know is that every column matcher, when invoked on the row you're currently testing, returns true. So, as the predicate argument to <code><b>EVERY</b></code>, you pass yet another closure that <code><b>FUNCALL</b></code>s the column matcher, passing it the row.
        </p>
        <p>
            Another matching function that you'll occasionally find useful is <code>in</code>, which returns a function that matches rows where a particular column is in a given set of values. You'll define <code>in</code> to take two arguments: a column name and a table that contains the values you want to match. For instance, suppose you wanted to find all the songs in the MP3 database that have names the same as a song performed by the Dixie Chicks. You can write that where clause using <code>in</code> and a sub<code>select</code> like this:<sup>4</sup>
        </p>
        <pre>
(select
  :columns '(:artist :song)
  :from *mp3s*
  :where (in :song 
             (select
               :columns :song
               :from *mp3s*
               :where (matching *mp3s* :artist "Dixie Chicks"))))
</pre>
        <p>
            Although the queries are more complex, the definition of <code>in</code> is much simpler than that of <code>matching</code>.
        </p>
        <pre>
(defun in (column-name table)
  (let ((test (equality-predicate (find-column column-name (schema table))))
        (values (map 'list #'(lambda (r) (getf r column-name)) (rows table))))
    #'(lambda (row)
        (member (getf row column-name) values :test test))))
</pre>
        <h2>
            <a name="getting-at-the-results" id="getting-at-the-results">Getting at the Results</a>
        </h2>
        <p>
            Since <code>select</code> returns another <code>table</code>, you need to think a bit about how you want to get at the individual row and column values in a table. If you're sure you'll never want to change the way you represent the data in a table, you can just make the structure of a table part of the API--that <code>table</code> has a slot <code>rows</code> that's a vector of plists--and use all the normal Common Lisp functions for manipulating vectors and plists to get at the values in the table. But that representation is really an internal detail that you might want to change. Also, you don't necessarily want other code manipulating the data structures directly--for instance, you don't want anyone to use <code><b>SETF</b></code> to put an unnormalized column value into a row. So it might be a good idea to define a few abstractions that provide the operations you want to support. Then if you decide to change the internal representation later, you'll need to change only the implementation of these functions and macros. And while Common Lisp doesn't enable you to absolutely prevent folks from getting at "internal" data, by providing an official API you at least make it clear where the boundary is.
        </p>
        <p>
            Probably the most common thing you'll need to do with the results of a query is to iterate over the individual rows and extract specific column values. So you need to provide a way to do both those things without touching the <code>rows</code> vector directly or using <code><b>GETF</b></code> to get at the column values within a row.
        </p>
        <p>
            For now these operations are trivial to implement; they're merely wrappers around the code you'd write if you didn't have these abstractions. You can provide two ways to iterate over the rows of a table: a macro <code>do-rows</code>, which provides a basic looping construct, and a function <code>map-rows</code>, which builds a list containing the results of applying a function to each row in the table.<sup>5</sup>
        </p>
        <pre>
(defmacro do-rows ((row table) &amp;body body)
  `(loop for ,row across (rows ,table) do ,@body))

(defun map-rows (fn table)
  (loop for row across (rows table) collect (funcall fn row)))
</pre>
        <p>
            To get at individual column values within a row, you should provide a function, <code>column-value</code>, that takes a row and a column name and returns the appropriate value. Again, it's a trivial wrapper around the code you'd write otherwise. But if you change the internal representation of a table later, users of <code>column-value</code> needn't be any the wiser.
        </p>
        <pre>
(defun column-value (row column-name)
  (getf row column-name))
</pre>
        <p>
            While <code>column-value</code> is a sufficient abstraction for getting at column values, you'll often want to get at the values of multiple columns at once. So you can provide a bit of syntactic sugar, a macro, <code>with-column-values</code>, that binds a set of variables to the values extracted from a row using the corresponding keyword names. Thus, instead of writing this:
        </p>
        <pre>
 (do-rows (row table)
   (let ((song (column-value row :song))
         (artist (column-value row :artist))
         (album (column-value row :album)))
     (format t "~a by ~a from ~a~%" song artist album)))
</pre>
        <p>
            you can simply write the following:
        </p>
        <pre>
(do-rows (row table)
  (with-column-values (song artist album) row
    (format t "~a by ~a from ~a~%" song artist album)))
</pre>
        <p>
            Again, the actual implementation isn't complicated if you use the <code>once-only</code> macro from Chapter 8.
        </p>
        <pre>
(defmacro with-column-values ((&amp;rest vars) row &amp;body body)
  (once-only (row)
    `(let ,(column-bindings vars row) ,@body)))

(defun column-bindings (vars row)
  (loop for v in vars collect `(,v (column-value ,row ,(as-keyword v)))))

(defun as-keyword (symbol)
  (intern (symbol-name symbol) :keyword))
</pre>
        <p>
            Finally, you should provide abstractions for getting at the number of rows in a table and for accessing a specific row by numeric index.
        </p>
        <pre>
(defun table-size (table)
  (length (rows table)))

(defun nth-row (n table)
  (aref (rows table) n))
</pre>
        <h2>
            <a name="other-database-operations" id="other-database-operations">Other Database Operations</a>
        </h2>
        <p>
            Finally, you'll implement a few other database operations that you'll need in Chapter 29. The first two are analogs of the SQL <code>DELETE</code> statement. The function <code>delete-rows</code> is used to delete rows from a table that match particular criteria. Like <code>select</code>, it takes <code>:from</code> and <code>:where</code> keyword arguments. Unlike <code>select</code>, it doesn't return a new table--it actually modifies the table passed as the <code>:from</code> argument.
        </p>
        <pre>
(defun delete-rows (&amp;key from where)
  (loop
     with rows = (rows from)
     with store-idx = 0
     for read-idx from 0
     for row across rows
     do (setf (aref rows read-idx) nil)
     unless (funcall where row) do
       (setf (aref rows store-idx) row)
       (incf store-idx)
     finally (setf (fill-pointer rows) store-idx)))
</pre>
        <p>
            In the interest of efficiency, you might want to provide a separate function for deleting all the rows from a table.
        </p>
        <pre>
(defun delete-all-rows (table)
  (setf (rows table) (make-rows *default-table-size*)))
</pre>
        <p>
            The remaining table operations don't really map to normal relational database operations but will be useful in the MP3 browser application. The first is a function to sort the rows of a table in place.
        </p>
        <pre>
(defun sort-rows (table &amp;rest column-names)
  (setf (rows table) (sort (rows table) (row-comparator column-names (schema table))))
  table)
</pre>
        <p>
            On the flip side, in the MP3 browser application, you'll need a function that shuffles a table's rows in place using the function <code>nshuffle-vector</code> from Chapter 23.
        </p>
        <pre>
(defun shuffle-table (table)
  (nshuffle-vector (rows table))
  table)
</pre>
        <p>
            And finally, again for the purposes of the MP3 browser, you should provide a function that selects <i>n</i> random rows, returning the results as a new table. It also uses <code>nshuffle-vector</code> along with a version of <code>random-sample</code> based on Algorithm S from Donald Knuth's <i>The Art of Computer Programming, Volume 2: Seminumerical Algorithms</i>, Third Edition (Addison-Wesley, 1998) that I discussed in Chapter 20.
        </p>
        <pre>
(defun random-selection (table n)
  (make-instance
   'table
   :schema (schema table)
   :rows (nshuffle-vector (random-sample (rows table) n))))

(defun random-sample (vector n)
  "Based on Algorithm S from Knuth. TAOCP, vol. 2. p. 142"
  (loop with selected = (make-array n :fill-pointer 0)
     for idx from 0
     do
       (loop
          with to-select = (- n (length selected))
          for remaining = (- (length vector) idx)
          while (&gt;= (* remaining (random 1.0)) to-select)
          do (incf idx))
       (vector-push (aref vector idx) selected)
     when (= (length selected) n) return selected))
</pre>
        <p>
            With this code you'll be ready, in Chapter 29, to build a Web interface for browsing a collection of MP3 files. But before you get to that, you need to implement the part of the server that streams MP3s using the Shoutcast protocol, which is the topic of the next chapter.
        </p>
        <hr>
        <div class="notes">
            <p>
                <sup>1</sup>The general theory behind interning objects is that if you're going to compare a particular value many times, it's worth it to pay the cost of interning it. The <code>value-normalizer</code> runs once when you insert a value into the table and, as you'll see, once at the beginning of each query. Since a query can involve invoking the <code>equality-predicate</code> once per row in the table, the amortized cost of interning the values will quickly approach zero.
            </p>
            <p>
                <sup>2</sup>As always, the first causality of concise exposition in programming books is proper error handling; in production code you'd probably want to define your own error type, such as the following, and signal it instead:
            </p>
            <pre>
(error 'illegal-column-value :value value :column column)
</pre>
            <p>
                Then you'd want to think about where you can add restarts that might be able to recover from this condition. And, finally, in any given application you could establish condition handlers that would choose from among those restarts.
            </p>
            <p>
                <sup>3</sup>If any MP3 files have malformed data in the track and year frames, <code><b>PARSE-INTEGER</b></code> could signal an error. One way to deal with that is to pass <code><b>PARSE-INTEGER</b></code> the <code>:junk-allowed</code> argument of <code><b>T</b></code>, which will cause it to ignore any non-numeric junk following the number and to return <code><b>NIL</b></code> if no number can be found in the string. Or, if you want practice at using the condition system, you could define an error and signal it from these functions when the data is malformed and also establish a few restarts to allow these functions to recover.
            </p>
            <p>
                <sup>4</sup>This query will also return all the songs performed by the Dixie Chicks. If you want to limit it to songs by artists other than the Dixie Chicks, you need a more complex <code>:where</code> function. Since the <code>:where</code> argument can be any function, it's certainly possible; you could remove the Dixie Chicks' own songs with this query:
            </p>
            <pre>
(let* ((dixie-chicks (matching *mp3s* :artist "Dixie Chicks"))
       (same-song (in :song (select :columns :song :from *mp3s* :where dixie-chicks)))
       (query #'(lambda (row) (and (not (funcall dixie-chicks row)) (funcall same-song row)))))
  (select :columns '(:artist :song) :from *mp3s* :where query))
</pre>
            <p>
                This obviously isn't quite as convenient. If you were going to write an application that needed to do lots of complex queries, you might want to consider coming up with a more expressive query language.
            </p>
            <p>
                <sup>5</sup>The version of <code><b>LOOP</b></code> implemented at M.I.T. before Common Lisp was standardized included a mechanism for extending the <code><b>LOOP</b></code> grammar to support iteration over new data structures. Some Common Lisp implementations that inherited their <code><b>LOOP</b></code> implementation from that code base may still support that facility, which would make <code>do-rows</code> and <code>map-rows</code> less necessary.
            </p>
        </div>
        <div class="copyright">
            Copyright Â© 2003-2005, Peter Seibel
        </div>
    </body>
</html>
